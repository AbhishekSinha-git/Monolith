import { 

  FiMcpConfig,
  FiMcpCredentials,
  FiMcpStreamOptions,
  FiMcpStreamConnection,
  FiMcpStreamEvent,
  FiMcpUserData,
  Account,
  NetWorth
} from '../types/mcp';
import WebSocket from 'ws';
import fetch from 'node-fetch';

// Types for authentication responses
interface AuthResponse {
  user_id: string;
  access_token: string;
  refresh_token: string;
  expires_in: number;
  passcode?: string;
}

class FiMcpService {
  private config: FiMcpConfig;
  private connections: Map<string, FiMcpStreamConnection>;
  private userData: Map<string, FiMcpUserData>;

  constructor(config: FiMcpConfig) {
    this.config = config;
    this.connections = new Map();
    this.userData = new Map();
  }

  // WebSocket connection management
  async connectStream(
    credentials: FiMcpCredentials,
    options: FiMcpStreamOptions = {}
  ): Promise<void> {
    const { userId, accessToken, passcode } = credentials;

    if (this.connections.has(userId)) {
      await this.disconnectStream(userId);
    }

    try {
      const socket = new WebSocket(this.config.streamEndpoint, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'X-Fi-Passcode': passcode || '',
        },
      });

      const connection: FiMcpStreamConnection = {
        userId,
        socket,
        reconnectAttempts: 0,
        isActive: true,
      };

      this.setupSocketHandlers(connection, options, credentials);
      this.connections.set(userId, connection);
    } catch (error) {
      console.error('Fi MCP stream connection error:', error);
      throw error;
    }
  }

  async disconnectStream(userId: string): Promise<void> {
    const connection = this.connections.get(userId);
    if (connection) {
      connection.isActive = false;
      connection.socket.close();
      this.connections.delete(userId);
    }
  }

  private handleStreamEvent(userId: string, event: FiMcpStreamEvent): void {
    let userData = this.userData.get(userId);
    if (!userData) {
      // Initialize user data with empty values
      userData = {
        userId,
        assets: [],
        liabilities: [],
        bankAccounts: [],
        portfolio: {
          netWorth: { currency: 'INR', value: 0 },
          assets: {
            total: { currency: 'INR', value: 0 },
            breakdown: {
              mutualFunds: { currency: 'INR', value: 0 },
              stocks: { currency: 'INR', value: 0 },
              fixedDeposits: { currency: 'INR', value: 0 },
              realEstate: { currency: 'INR', value: 0 },
              esop: { currency: 'INR', value: 0 },
              epf: { currency: 'INR', value: 0 },
              nps: { currency: 'INR', value: 0 },
              cash: { currency: 'INR', value: 0 }
            }
          },
          liabilities: {
            total: { currency: 'INR', value: 0 },
            breakdown: {
              loans: { currency: 'INR', value: 0 },
              creditCards: { currency: 'INR', value: 0 }
            }
          },
          returns: {},
          lastUpdated: new Date().toISOString()
        },
        lastUpdated: new Date().toISOString()
      };
      this.userData.set(userId, userData);
    }

    switch (event.type) {
      case 'ASSET_UPDATE':
        userData.assets = event.payload.assets;
        break;
      case 'LIABILITY_UPDATE':
        userData.liabilities = event.payload.liabilities;
        break;
      case 'BANK_UPDATE':
        userData.bankAccounts = event.payload.bankAccounts;
        break;
      case 'PORTFOLIO_UPDATE':
        userData.portfolio = {
          ...userData.portfolio,
          ...event.payload.portfolio,
          lastUpdated: event.timestamp
        };
        break;
      case 'CONNECTION_STATUS':
        // Handle connection status changes
        break;
      case 'ERROR':
        console.error('Fi MCP stream error event:', event.payload);
        break;
    }

    userData.lastUpdated = event.timestamp;
  }

  private setupSocketHandlers(
    connection: FiMcpStreamConnection,
    options: FiMcpStreamOptions,
    credentials: FiMcpCredentials
  ): void {
    const { socket, userId } = connection;

    socket.addListener('open', () => {
      console.log(`Fi MCP stream connected for user ${userId}`);
      connection.reconnectAttempts = 0;
      
      // Setup ping interval if specified
      if (options.pingInterval) {
        setInterval(() => {
          if (socket.readyState === WebSocket.OPEN) {
            socket.ping();
            connection.lastPing = new Date();
          }
        }, options.pingInterval);
      }
    });

    socket.addListener('message', (data: WebSocket.RawData) => {
      try {
        const event: FiMcpStreamEvent = JSON.parse(data.toString());
        this.handleStreamEvent(userId, event);
      } catch (error) {
        console.error('Fi MCP stream message parsing error:', error);
      }
    });

    socket.addListener('close', async () => {
      console.log(`Fi MCP stream closed for user ${userId}`);
      if (connection.isActive && options.maxReconnectAttempts && options.reconnectInterval) {
        if (connection.reconnectAttempts < options.maxReconnectAttempts) {
          connection.reconnectAttempts++;
          setTimeout(async () => {
            try {
              // Refresh the token before reconnecting
              const newCredentials = await this.refreshToken(credentials);
              await this.connectStream(newCredentials, options);
            } catch (error) {
              console.error('Fi MCP reconnection error:', error);
            }
          }, options.reconnectInterval);
        }
      }
    });

    socket.addListener('error', (error: Error) => {
      console.error(`Fi MCP stream error for user ${userId}:`, error);
    });
  }

  // Helper function to create Account objects with proper type validation
  private createAccount(
    id: string,
    name: string,
    type: 'SAVINGS' | 'CREDIT_CARD' | 'LOAN',
    balance: number
  ): Account {
    return {
      id,
      name,
      type,
      balance,
      currency: 'INR' as const
    };
  }

  // Data access methods that maintain backward compatibility
  async getAccounts(userId: string): Promise<Account[]> {
    const userData = this.userData.get(userId);
    if (!userData) {
      throw new Error('User data not found. Please ensure the user is connected.');
    }

    const accounts: Account[] = [
      // Bank accounts are mapped to savings accounts
      ...userData.bankAccounts.map(account => 
        this.createAccount(
          account.id,
          account.bankName + " Account",
          'SAVINGS',
          account.balance.value
        )
      ),
      // All assets are mapped to savings accounts
      ...userData.assets.map(asset =>
        this.createAccount(
          asset.id,
          asset.name,
          'SAVINGS',
          asset.value.value
        )
      ),
      // Map liabilities to appropriate account types
      ...userData.liabilities.map(liability =>
        this.createAccount(
          liability.id,
          liability.name,
          liability.type === 'CREDIT_CARD' ? 'CREDIT_CARD' : 'LOAN',
          -liability.amount.value
        )
      )
    ];
    return accounts;
  }

  async getNetWorth(userId: string): Promise<NetWorth[]> {
    const userData = this.userData.get(userId);
    if (!userData || !userData.portfolio) {
      throw new Error('User portfolio data not found. Please ensure the user is connected.');
    }
    
    // For now, we only return the latest net worth since historical data is not available
    return [{
      date: userData.portfolio.lastUpdated,
      amount: userData.portfolio.netWorth.value
    }];
  }

  // Authentication methods
  async authenticate(code: string): Promise<FiMcpCredentials> {
    try {
      const response = await fetch(this.config.authEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          client_id: this.config.clientId,
          client_secret: this.config.clientSecret,
          grant_type: 'authorization_code',
          code,
          redirect_uri: this.config.redirectUri,
        }),
      });

      if (!response.ok) {
        throw new Error('Authentication failed');
      }

      const data = await response.json() as AuthResponse;
      return {
        userId: data.user_id,
        accessToken: data.access_token,
        refreshToken: data.refresh_token,
        expiresAt: new Date(Date.now() + data.expires_in * 1000),
        passcode: data.passcode,
      };
    } catch (error) {
      console.error('Fi MCP authentication error:', error);
      throw error;
    }
  }

  async refreshToken(credentials: FiMcpCredentials): Promise<FiMcpCredentials> {
    try {
      const response = await fetch(this.config.authEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          client_id: this.config.clientId,
          client_secret: this.config.clientSecret,
          grant_type: 'refresh_token',
          refresh_token: credentials.refreshToken,
        }),
      });

      if (!response.ok) {
        throw new Error('Token refresh failed');
      }

      const data = await response.json() as AuthResponse;
      return {
        ...credentials,
        accessToken: data.access_token,
        refreshToken: data.refresh_token,
        expiresAt: new Date(Date.now() + data.expires_in * 1000),
      };
    } catch (error) {
      console.error('Fi MCP token refresh error:', error);
      throw error;
    }
  }

  // Connection management methods
  async getConnectionStatus(userId: string): Promise<{ isConnected: boolean; lastUpdated?: string }> {
    const userData = this.userData.get(userId);
    if (!userData) {
      return { isConnected: false };
    }
    return {
      isConnected: this.connections.has(userId),
      lastUpdated: userData.lastUpdated
    };
  }

  async initiateConnection(userId: string): Promise<string> {
    // Generate the authorization URL for the user
    const authUrl = getAuthorizationUrl(this.config);
    // You might want to store the state parameter and validate it later
    return authUrl;
  }

  async completeConnection(userId: string, code: string): Promise<void> {
    // Authenticate with the received code
    const credentials = await this.authenticate(code);
    
    if (credentials.userId !== userId) {
      throw new Error('User ID mismatch during connection completion');
    }

    // Connect to the WebSocket stream with default options
    await this.connectStream(credentials);
  }

  async refreshConnection(userId: string): Promise<void> {
    const connection = this.connections.get(userId);
    if (!connection) {
      throw new Error('No active connection found for user');
    }

    // Close the existing connection
    await this.disconnectStream(userId);

    // Get stored credentials (you might want to implement credential storage)
    // For now, we'll throw an error indicating the need to reconnect
    throw new Error('Please reconnect using the authentication flow');
  }

  async disconnect(userId: string): Promise<void> {
    await this.disconnectStream(userId);
    this.userData.delete(userId);
  }
}

// Helper function to generate the OAuth2.0 authorization URL
export const getAuthorizationUrl = (config: FiMcpConfig): string => {
  const params = new URLSearchParams({
    response_type: 'code',
    client_id: config.clientId,
    redirect_uri: config.redirectUri,
    scope: config.scopes.join(' '),
    state: Math.random().toString(36).substring(7), // Random state for CSRF protection
  });

  return `${config.authEndpoint}?${params.toString()}`;
};

export default FiMcpService;